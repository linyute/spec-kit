---
description: 從自然語言特徵描述建立或更新特徵規格。
handoffs: 
  - label: Build Technical Plan
    agent: speckit.plan
    prompt: Create a plan for the spec. I am building with...
  - label: Clarify Spec Requirements
    agent: speckit.clarify
    prompt: Clarify specification requirements
    send: true
scripts:
  sh: scripts/bash/create-new-feature.sh --json "{ARGS}"
  ps: scripts/powershell/create-new-feature.ps1 -Json "{ARGS}"
---

## 使用者輸入

```text
$ARGUMENTS
```

您**必須**在繼續之前考慮使用者輸入（如果非空）。

## 概述

使用者在觸發訊息中在 `/speckit.specify` 之後輸入的文字**是**特徵描述。即使 `{ARGS}` 字面上出現在下方，也請假定您在本次對話中始終可以使用它。除非使用者提供了空命令，否則不要要求他們重複。

根據該特徵描述，執行以下操作：

1. **為分支產生一個簡潔的短名稱**（2-4 個詞）：
   - 分析特徵描述並提取最有意義的關鍵字
   - 建立一個 2-4 個詞的短名稱，捕捉特徵的精髓
   - 盡可能使用動作-名詞格式（例如，"add-user-auth", "fix-payment-bug"）
   - 保留技術術語和首字母縮略詞（OAuth2, API, JWT 等）
   - 保持簡潔但足以描述特徵，一目了然
   - 範例：
     - "I want to add user authentication" → "user-auth"
     - "Implement OAuth2 integration for the API" → "oauth2-api-integration"
     - "Create a dashboard for analytics" → "analytics-dashboard"
     - "Fix payment processing timeout bug" → "fix-payment-timeout"

2. **在建立新分支之前檢查現有分支**：

   a. 首先，獲取所有遠端分支，確保我們有最新資訊：

      ```bash
      git fetch --all --prune
      ```

   b. 為短名稱在所有來源中找到最高的特徵號：
      - 遠端分支：`git ls-remote --heads origin | grep -E 'refs/heads/[0-9]+-<short-name>$'`
      - 本地分支：`git branch | grep -E '^[* ]*[0-9]+-<short-name>$'`
      - 規格目錄：檢查匹配 `specs/[0-9]+-<short-name>` 的目錄

   c. 確定下一個可用號碼：
      - 從所有三個來源提取所有號碼
      - 找到最高號碼 N
      - 新分支號碼使用 N+1

   d. 使用計算出的號碼和短名稱執行腳本 `{SCRIPT}`：
      - 傳遞 `--number N+1` 和 `--short-name "your-short-name"` 以及特徵描述
      - Bash 範例：`{SCRIPT} --json --number 5 --short-name "user-auth" "Add user authentication"`
      - PowerShell 範例：`{SCRIPT} -Json -Number 5 -ShortName "user-auth" "Add user authentication"`

   **重要**：
   - 檢查所有三個來源（遠端分支、本地分支、規格目錄）以找到最高號碼
   - 僅匹配具有確切短名稱模式的分支/目錄
   - 如果沒有找到具有此短名稱的現有分支/目錄，則從 1 開始
   - 每個特徵您只能執行此腳本一次
   - JSON 作為輸出在終端機中提供 - 始終參考它以獲取您正在尋找的實際內容
   - JSON 輸出將包含 BRANCH_NAME 和 SPEC_FILE 路徑
   - 對於像 "I'm Groot" 這樣的參數中的單引號，請使用轉義語法：例如 'I'\''m Groot'（如果可能，也可以使用雙引號："I'm Groot"）

3. 載入 `templates/spec-template.md` 以了解所需部分。

4. 遵循此執行流程：

    1. 從輸入中解析使用者描述
       如果為空：錯誤 "未提供特徵描述"
    2. 從描述中提取關鍵概念
       識別：參與者、動作、資料、約束
    3. 對於不明確的方面：
       - 根據上下文和行業標準進行有根據的推測
       - 僅當以下情況才標記為 [NEEDS CLARIFICATION: specific question]：
         - 選擇顯著影響特徵範圍或使用者體驗
         - 存在多種合理的解釋且具有不同的影響
         - 不存在合理的預設值
       - **限制：總共最多 3 個 [NEEDS CLARIFICATION] 標記**
       - 根據影響優先級別澄清：範圍 > 安全/隱私 > 使用者體驗 > 技術細節
    4. 填寫使用者情境與測試部分
       如果沒有清晰的使用者流程：錯誤 "無法確定使用者情境"
    5. 產生功能需求
       每個需求都必須可測試
       對未指定細節使用合理的預設值（在假設部分中記錄假設）
    6. 定義成功標準
       建立可衡量、與技術無關的結果
       包括定量指標（時間、效能、量）和定性措施（使用者滿意度、任務完成度）
       每個標準都必須無需實作細節即可驗證
    7. 識別關鍵實體（如果涉及資料）
    8. 返回：成功（規格準備好進行規劃）

5. 使用範本結構將規格寫入 SPEC_FILE，用從特徵描述（參數）派生的具體細節替換佔位符，同時保留章節順序和標題。

6. **規格品質驗證**：在編寫初始規格後，根據品質標準對其進行驗證：

   a. **建立規格品質檢查表**：在 `FEATURE_DIR/checklists/requirements.md` 中產生一個檢查表檔案，使用包含這些驗證項目的檢查表範本結構：

      ```markdown
      # 規格品質檢查表：[特徵名稱] 
      
      **目的**：在進行規劃之前驗證規格的完整性和品質
      **建立日期**：[日期]
      **特徵**：[指向 spec.md 的連結]
      
      ## 內容品質
      
      - [ ] 沒有實作細節（語言、框架、API）
      - [ ] 專注於使用者價值和業務需求
      - [ ] 為非技術利害關係人編寫
      - [ ] 所有強制部分已完成
      
      ## 需求完整性
      
      - [ ] 沒有 [NEEDS CLARIFICATION] 標記保留
      - [ ] 需求是可測試且明確的
      - [ ] 成功標準是可衡量的
      - [ ] 成功標準與技術無關（沒有實作細節）
      - [ ] 所有接受情境都已定義
      - [ ] 邊緣案例已識別
      - [ ] 範圍已明確劃定
      - [ ] 依賴關係和假設已識別
      
      ## 特徵就緒程度
      
      - [ ] 所有功能需求都有清晰的接受標準
      - [ ] 使用者情境涵蓋主要流程
      - [ ] 特徵符合成功標準中定義的可衡量結果
      - [ ] 沒有實作細節洩露到規格中
      
      ## 備註
      
      - 標記為未完成的項目需要在 `/speckit.clarify` 或 `/speckit.plan` 之前進行規格更新
      ```

   b. **執行驗證檢查**：根據每個檢查表項目審查規格：
      - 對於每個項目，確定它是通過還是失敗
      - 記錄發現的具體問題（引用相關的規格部分）

   c. **處理驗證結果**：

      - **如果所有項目都通過**：將檢查表標記為完成並繼續執行步驟 6

      - **如果項目失敗（不包括 [NEEDS CLARIFICATION]）**：
        1. 列出失敗的項目和具體問題
        2. 更新規格以解決每個問題
        3. 重新執行驗證，直到所有項目都通過（最多 3 次迭代）
        4. 如果在 3 次迭代後仍然失敗，則在檢查表備註中記錄其餘問題並警告使用者

      - **如果 [NEEDS CLARIFICATION] 標記仍然存在**：
        1. 從規格中提取所有 [NEEDS CLARIFICATION: ...] 標記
        2. **限制檢查**：如果存在超過 3 個標記，則僅保留 3 個最關鍵的（按範圍/安全/UX 影響）並對其餘的進行有根據的推測
        3. 對於每個需要的澄清（最多 3 個），以以下格式向使用者呈現選項：

           ```markdown
           ## 問題 [N]：[主題] 
           
           **上下文**：[引用相關的規格部分]
           
           **我們需要知道什麼**：[來自 NEEDS CLARIFICATION 標記的具體問題]
           
           **建議答案**：
           
           | 選項 | 答案 | 影響 |
           |--------|--------|--------------|
           | A      | [第一個建議答案] | [這對特徵意味著什麼] |
           | B      | [第二個建議答案] | [這對特徵意味著什麼] |
           | C      | [第三個建議答案] | [這對特徵意味著什麼] |
           | 自訂 | 提供您自己的答案 | [解釋如何提供自訂輸入] |
           
           **您的選擇**：_[等待使用者回應]_
           ```

        4. **關鍵 - 表格格式**：確保 Markdown 表格格式正確：
           - 使用一致的間距，管線對齊
           - 每個單元格應在內容周圍有空格：`| 內容 |` 而不是 `|內容|`
           - 標題分隔符必須至少有 3 個破折號：`|--------|`
           - 測試表格在 Markdown 預覽中是否正確渲染
        5. 問題依序編號（Q1, Q2, Q3 - 總共最多 3 個）
        6. 在等待回應之前將所有問題一起呈現
        7. 等待使用者回應他們對所有問題的選擇（例如，"Q1: A, Q2: 自訂 - [詳細資訊], Q3: B"）
        8. 透過將每個 [NEEDS CLARIFICATION] 標記替換為使用者選擇或提供的答案來更新規格
        9. 在所有澄清都解決後重新執行驗證

   d. **更新檢查表**：每次驗證迭代後，更新檢查表檔案中的當前通過/失敗狀態

7. 報告完成情況，包括分支名稱、規格檔案路徑、檢查表結果以及為下一階段（`/speckit.clarify` 或 `/speckit.plan`）做好準備。

**注意**：此腳本在編寫之前建立並簽出新分支並初始化規格檔案。

## 一般準則

## 快速準則

- 專注於使用者需要**什麼**以及**為什麼**。
- 避免討論如何實作（沒有技術堆疊、API、程式碼結構）。
- 為業務利害關係人而非開發人員編寫。
- 不要建立任何嵌入在規格中的檢查表。那將是一個單獨的命令。

### 章節要求

- **強制章節**：每個特徵都必須完成
- **可選章節**：僅在與特徵相關時才包含
- 當某個章節不適用時，將其完全刪除（不要保留為 "N/A"）

### 適用於 AI 生成

從使用者提示建立此規格時：

1. **進行有根據的推測**：使用上下文、行業標準和常見模式來填補空白
2. **記錄假設**：在假設部分中記錄合理的預設值
3. **限制澄清**：最多 3 個 [NEEDS CLARIFICATION] 標記 - 僅用於以下關鍵決策：
   - 顯著影響特徵範圍或使用者體驗
   - 存在多種合理的解釋且具有不同的影響
   - 缺乏任何合理的預設值
4. **優先級別澄清**：範圍 > 安全/隱私 > 使用者體驗 > 技術細節
5. **像測試人員一樣思考**：每個模糊的需求都應未能通過「可測試且明確」的檢查表項目
6. **需要澄清的常見領域**（僅當沒有合理的預設值時）：
   - 特徵範圍和邊界（包含/排除特定用例）
   - 使用者類型和權限（如果可能存在多種衝突的解釋）
   - 安全/合規要求（當具有法律/財務上的重要性時）

**合理的預設值範例**（無需詢問這些）：

- 資料保留：行業領域的行業標準實踐
- 效能目標：除非另有說明，否則為標準網站/行動應用程式預期
- 錯誤處理：使用者友善的訊息和適當的回退
- 身份驗證方法：對於網路應用程式，標準的基於會話的或 OAuth2
- 整合模式：RESTful API，除非另有說明

### 成功標準準則

成功標準必須：

1. **可衡量**：包括具體指標（時間、百分比、數量、比率）
2. **與技術無關**：不提及框架、語言、資料庫或工具
3. **以使用者為中心**：從使用者/業務角度描述結果，而不是系統內部
4. **可驗證**：可以在不知道實作細節的情況下進行測試/驗證

**好的範例**：

- 「使用者可以在 3 分鐘內完成結帳」
- 「系統支持 10,000 個並發使用者」
- 「95% 的搜尋在一秒內返回結果」
- 「任務完成率提高 40%」

**壞的範例**（以實作為中心）：

- 「API 回應時間在 200 毫秒以下」（技術性太強，請使用「使用者立即看到結果」）
- 「資料庫可以處理 1000 TPS」（實作細節，請使用面向使用者指標）
- 「React 元件高效渲染」（框架特定）
- 「Redis 快取命中率高於 80%」（技術特定）
